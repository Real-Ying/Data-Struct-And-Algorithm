typedef struct LNode(){
	ElemType data;
	struct LNode *next;
}LNode,*LikeList;

//建立(头插法)
LikeList CreatList1(LikeList &L){
	LNode *s,x;
	L=(LikeList)malloc(sizeof(LNode));    
	L->nest=NULL;    
	scanf("%d",&x);    
	while(x!=9999){
		s=(LNode*)malloc(sizeof(LNode));    
		
		s->data=x;   
		s->next=L->next;    
		L->next=s;
		
		scanf("%d",&x);
	}
	retirun L;
}

//建立(尾插法)
LikeList CreatList2(LinkList &L){
	int x;
	L=(LikeList)malloc(sizeof(LNode));
	LNode *s,*r=L;    
	scanf("%d",&x);
	while(x!=9999){
		s=(LNode*)malloc(sizeof(LNode));
		
		s->data=x;
		r->next=s;
		r=s;   
		
		scanf("%d",&x);
	}
	r->next=NULL;    
	return L;    
}

//查找（按位返回值）
LNode *GetElem(LinkList L,int i){
    int j=1;     
    LNode *p=L—>Next;    
    if(i==0)     
        return L；
    if(i<1)       
        return Null;
    while(p&&j<i){    
        p=p—>next；
        j++; }
    return p; }
    
//查找（按值返回位）
LNode *GetLocate(LinkList L,ElemType e){
    LNode *p=L—>Next；
    while(p!=Null&&p—>data!=e){   
        p=p—>Next;
    return p; }
    

//插入（后插）
1.p=GetElem(L,i-1);  
2.s—>next=p—>next;    
3.p—>next=s;          

//插入（前插）
1.s—>next=p—>next;     
2.p—>next=s;
3.temp=p->data;       
4.p->data=s->data;
5.s->data=temp;

//删除（按位1）
p=GetElem(L,i-1);   //查找删除位置前驱结点
q=p->next;    //令q指向被删除结点
p->next=q->next;    //令前驱结点指向删除结点的下一位，从而q从链中断开
free(q);

//删除（按位2）
//思想：这里是给了删除结点位置*p,假设该位置是前驱结点，然后交换这个结点与其后继结点的值，最后删除后继结点
q=p->next;    //q指向p的后继结点
p->data=p->nest->data;    //删除点与其后继交换数据
p->next=q->next;    //q从链中断开(交换值后的后继结点)
free(q);
